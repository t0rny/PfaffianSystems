var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PfaffianSystems","category":"page"},{"location":"#PfaffianSystems","page":"Home","title":"PfaffianSystems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PfaffianSystems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PfaffianSystems]","category":"page"},{"location":"#PfaffianSystems.DIdeal","page":"Home","title":"PfaffianSystems.DIdeal","text":"DIdeal <: AbstractIdeal\n\nD-Ideal type\n\n\n\n\n\n","category":"type"},{"location":"#PfaffianSystems.PfaffianSystem","page":"Home","title":"PfaffianSystems.PfaffianSystem","text":"Pfaffian system\n\n\n\n\n\n","category":"type"},{"location":"#PfaffianSystems.addVars-Tuple{AbstractString, Bijections.Bijection{Symbolics.Num, Symbolics.Num}}","page":"Home","title":"PfaffianSystems.addVars","text":"addVars(name::AbstractString[, n::Integer, v2d::Bijection])\n\nGenerate a Symbolics variable name and its corresponding differential operator dname. When n is given, generate vectors [name1...namen] and [dname1...dnamen].  The correspondence between name and dname is added to the bijection v2d. \n\nExamples\n\njulia> x, dx, v2d = genVars(\"x\")\n(x, dx, Bijection{Symbolics.Num,Symbolics.Num} (with 1 pairs))\n\njulia> y, dy, v2d = addVars(\"y\", 2, v2d)\n(Symbolics.Num[y1, y2], Symbolics.Num[dy1, dy2], Bijection{Symbolics.Num,Symbolics.Num} (with 3 pairs))\n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.apply_doterm-Tuple{MultivariatePolynomials.AbstractTerm, Symbolics.Num, Bijections.Bijection, Bijections.Bijection{Symbolics.Num, Symbolics.Num}}","page":"Home","title":"PfaffianSystems.apply_doterm","text":"apply_dmon(DOmon::AbstractTerm, F::Num, p2s::Bijection, v2d::Bijection)\n\nApply a term of differential operator DOterm to an expression F.  The bijection p2s relates a MulltivariatePolunomials expression to a SymbolicUtils one, and d2v does a differential operator to its corresponding variable. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.eliminationIdeal-Tuple{DIdeal, OrderedCollections.OrderedSet{Symbolics.Num}}","page":"Home","title":"PfaffianSystems.eliminationIdeal","text":"eliminationIdeal(I::DIdeal, elim_vars::OrderedSet{Num})\neliminationIdeal(I::DIdeal, elim_vars::Vector{Num})\n\nReturn elimination ideal of I that does not include any variable of elim_vars. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.genVars-Tuple{AbstractString}","page":"Home","title":"PfaffianSystems.genVars","text":"genVars(name::AbstractString[, n::Integer])\n\nGenerate a Symbolics variable name and its corresponding differential operator dname. When n is given, generate vectors [name1...namen] and [dname1...dnamen].  The correspondence between name and dname is returned as a new bijection v2d, which will be provided to addVars. \n\nExamples\n\njulia> x, dx, v2d = genVars(\"x\")\n(x, dx, Bijection{Symbolics.Num,Symbolics.Num} (with 1 pairs))\n\njulia> y, dy, v2d = addVars(\"y\", 2, v2d)\n(Symbolics.Num[y1, y2], Symbolics.Num[dy1, dy2], Bijection{Symbolics.Num,Symbolics.Num} (with 3 pairs))\n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.intersectionIdeal-Tuple{Vararg{DIdeal}}","page":"Home","title":"PfaffianSystems.intersectionIdeal","text":"intersectionIdeal(Is::DIdeal...)\n\nReturn the intersection of the D-ideals Is[1], Is[2], ...\n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.isAsirAvailable-Tuple{}","page":"Home","title":"PfaffianSystems.isAsirAvailable","text":"Return the version of available Asir as an integer if exists, and otherwise return nothing. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.isZeroDimensional-Tuple{DIdeal}","page":"Home","title":"PfaffianSystems.isZeroDimensional","text":"isZeroDimensional(I::DIdeal)\n\nCheck if the ideal in R generated by DIdeal I is zero-dimensional. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.parseAsir-Tuple{AbstractString}","page":"Home","title":"PfaffianSystems.parseAsir","text":"parseAsir(asir_res::String)\n\nAdd square brackets and separete the response into lines. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.runAsir-Tuple{AbstractString}","page":"Home","title":"PfaffianSystems.runAsir","text":"runAsir(commands::AbstractString)\n\nRun commands on Asir. The raw response of Asir is returned as a string. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.stdmon!-Tuple{DIdeal, OrderedCollections.OrderedSet{Symbolics.Num}}","page":"Home","title":"PfaffianSystems.stdmon!","text":"stdmon!(I::DIdeal[, ordered_vars::Vector{Num}])\n\nCompute standard monomials if I is zero-dimensional as an ideal of R-ring. The order of varaibles in the computation of Grobner bases can be provided as ordered_vars, which can be omitted as long as the computational time is not crutial. \n\n\n\n\n\n","category":"method"},{"location":"#PfaffianSystems.vec2str-Tuple{AbstractVector}","page":"Home","title":"PfaffianSystems.vec2str","text":"vec2str(v::Vector{Num}; delim=\",\")\nvec2str(v::Symbolics.Arr; delim=\",\")\nvec2str(v::OrderedSet{Num}; delim=\",\")\n\nReturn a string consiting of all elements of v with delimiter delim. \n\n\n\n\n\n","category":"method"}]
}
